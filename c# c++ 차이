https://www.youtube.com/watch?v=dC1JdPDZRr0

컴파일 결과
- c++
고급언어 -> 저급언어(어셈블리어)

- c#
저급/기계어 위에 .net에서 실행 - 중간언어(IL-Intermidiate Language)

.net 
마이크로소프트사의 크로스플랫폼(환경에 제약 최소화 목적) 

플랫폼
- c++
환경중립적

- c#
.net플랫폼 위 실행
c++가 고->저로 변경하는것과 달리 중간 언어로 바꿔서 실행하기 때문에 컴파일 속도가 빠름(JIT-Just In Time)

값/참조타입
- c++ 
정적 선언 - value type
동적 선언/&참조형 - referance type

- c#
기본타입/구조체 - value type 
클래스 - referance type

인스턴스 생성
- c++
모든 자료형 동적/정적 custom 가능

- c#
기본타입 및 구조체 동적생성 불가

-- 기본적으로 구조체는 간단한 타입의 값들을 캡슐화하기 위함이므로 --
c++ 구조체가 에서는 기본 접근지정자 public인 class와 같이 동작하던 것과 달리
c# 에서는 값 타입으로만 지정가능 및 생성자와 상속 등의 파생 불가능
또한, c#에서 포인터 개념(지칭)은 있으나, 문법에선 삭제되었음

동적할당
- c++
포인터형으로 선언 및 지칭했고 수동 메모리해제

- c#
참조형으로 선언하고 (GC-Garbage Collector)가 메모리 자동해제
(동적할당시 포인터로 지칭함에 따라 강제되던 포인터문법 또한 정적과 같은 문법을 쓸 수 있는듯 함)

GC가 자동 할당해제하나, 시점이 모호해서(한가할 때?)
ex) c#기반의 unity로 제작한 게임의 경우 게임을 오래켜놓으면 GC가 실행되며 
속도가 저하되는 현상 발생할 수 있음
GC의 Collect등의 명령어로 할당해제시점 지정할 순 있으나, 기본적으로 .net의 판단하에 자동이기에 100% 보장은 불가

흐름 제어
- c# if,while등의 조건문에 bool 외 타입사용 불가
-> 모호성 방지 if (value = 0)가 비교가 아닌 대입후 비교임에도 문법이 헷갈려 에러나던 점 등등

- switch문 강화
-> 인자에 문자열 할당가능
-> 하나의 case(rable)에 break; 안걸어서 다음 case로 흐르던것 불가 - 모호성 방지
but 다수의 case를 하나의 동작으로 묶는건 가능

- for each문 지원
-> 기존 modern c++에서 쓰던 것과 같음
for(int e : arr) -> foreach(int e int arr) 형태로 사용 
